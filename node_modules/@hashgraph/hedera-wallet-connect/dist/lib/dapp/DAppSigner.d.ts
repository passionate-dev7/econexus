import { Signer, AccountBalance, AccountId, AccountInfo, Executable, Key, LedgerId, SignerSignature, Transaction, TransactionRecord } from '@hashgraph/sdk';
import type { CoreTypes, ISignClient } from '@walletconnect/types';
import { LogLevel } from '../shared/logger';
export declare class DAppSigner implements Signer {
    private readonly accountId;
    private readonly signClient;
    readonly topic: string;
    private readonly ledgerId;
    readonly extensionId?: string | undefined;
    private logger;
    constructor(accountId: AccountId, signClient: ISignClient, topic: string, ledgerId?: LedgerId, extensionId?: string | undefined, logLevel?: LogLevel);
    /**
     * Sets the logging level for the DAppSigner
     * @param level - The logging level to set
     */
    setLogLevel(level: LogLevel): void;
    private _getHederaClient;
    private get _signerAccountId();
    private _getRandomNodes;
    request<T>(request: {
        method: string;
        params: any;
    }): Promise<T>;
    getAccountId(): AccountId;
    getAccountKey(): Key;
    getLedgerId(): LedgerId;
    getNetwork(): {
        [key: string]: string | AccountId;
    };
    getMirrorNetwork(): string[];
    getAccountBalance(): Promise<AccountBalance>;
    getAccountInfo(): Promise<AccountInfo>;
    getAccountRecords(): Promise<TransactionRecord[]>;
    getMetadata(): CoreTypes.Metadata;
    sign(data: Uint8Array[], signOptions?: {
        encoding?: 'utf-8' | 'base64';
    }): Promise<SignerSignature[]>;
    checkTransaction<T extends Transaction>(transaction: T): Promise<T>;
    populateTransaction<T extends Transaction>(transaction: T): Promise<T>;
    /**
     * Prepares a transaction object for signing using a single node account id.
     * If the transaction object does not already have a node account id,
     * generate a random node account id using the Hedera SDK client
     *
     * @param transaction - Any instance of a class that extends `Transaction`
     * @returns transaction - `Transaction` object with signature
     */
    signTransaction<T extends Transaction>(transaction: T): Promise<T>;
    private _tryExecuteTransactionRequest;
    private _parseQueryResponse;
    /**
     * Executes a free receipt query without signing a transaction.
     * Enables the DApp to fetch the receipt of a transaction without making a new request
     * to the wallet.
     * @param request - The query to execute
     * @returns The result of the query
     */
    private executeReceiptQueryFromRequest;
    private _tryExecuteQueryRequest;
    call<RequestT, ResponseT, OutputT>(request: Executable<RequestT, ResponseT, OutputT>): Promise<OutputT>;
}
